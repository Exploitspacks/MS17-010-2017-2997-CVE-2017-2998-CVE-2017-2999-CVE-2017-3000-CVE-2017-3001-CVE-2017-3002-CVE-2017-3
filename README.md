# CVE-2017-2997-CVE-2017-2998-CVE-2017-2999-CVE-2017-3000-CVE-2017-3001-CVE-2017-3002-CVE-2017-3
Fully modified exploit for Ms17-010

----------------------------------------------

ETERNALBLACK 1.1.2125

What's new:

1) Made alteration and optimization of the engine code (nuclear shellcode) and the client

2) The principle of loading a payload has been changed. Now the process is divided into two parts:
Part 1 - TOUCH - Vulnerability check and bootstrap kernel shellcode with backdoor
Part 2 - UPLOAD&RUN - loading the actual peload and launching it. The size of the PL is limited to 1Mb (the run on all axes was carried out on this size of the PL)
  Accordingly, there are now 3 possible modes:
   1 mode - only TOUCH
   Mode 2 - TOUCH + UPLOAD&RUN
   Mode 3 - UPLOAD&RUN (download through a previously installed backdoor)
   The backdoor lasts until reboot. Nuclear backdoor (refused to use user agent)
   You can reload multiple times until the memory of the system process where we are injected is clogged.
   The target process can also be changed.
   This loader algorithm will drastically increase the reliability of loading the payload and reduce the likelihood of failure.

3) The code has been modified to work in multi-threaded mode.

;------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -;

ETERNALBLACK RCE.
Technical description and principle of operation.

1. Description of exploited vulnerabilities.

ETERNALBLACK is a combination of two exploits that use almost the same operating principles as
exploits from the FUZZBUNCH framework kit from Shadow Brokers Group. For convenience, both components of ETERNALBLACK are named
the same names as the 2 FUZZBUNCH components.

This is an exploit for ETERNALBLUE (covers 2008/W7/2008R2) and ETERNALROMANCE (XP/2003 x86/x64). Both exploits were patched by MS
03/14/2017 in MS17-010 security update package:

Windows XP with Service Pack 2 x86/x64 KB4012598
Windows XP with Service Pack 3 x86/x64 KB4012598
Windows Server 2003 SP1/SP2 x86/x64 KB4012598
Windows Vista with Service Pack 2 x86 KB4012598
Windows Vista with Service Pack 2 x64 KB4012598
Windows Server 2008 with Service Pack 2 x86 KB4012598
Windows Server 2008 with Service Pack 2 x64 KB401259
Windows 7 with Service Pack 1 x86 KB4012212 or KB4012215
Windows 7 with Service Pack 1 x64 KB4012212 or KB4012215
Windows Server 2008 R2 with Service Pack 1 KB4012212 or KB4012215
Windows 8.1 x86 KB4012213 or KB4012216
Windows 8.1 x64 KB4012213 or KB4012216
Windows Server 2012 KB4012214 or KB4012217
Windows Server 2012 R2 KB4012213 or KB4012216
Windows 10 x86 KB4012606
Windows 10 x64 KB4012606
Windows 10 version 1511 x86 KB4013198
Windows 10 version 1511 x64 KB4013198
Windows 10 version 1607 x86 KB4013429
Windows 10 version 1607 x64 KB4013429
Windows Server 2016 KB4013429

1.1 ETERNALROMANCE
This exploit is based on a vulnerability in the SMBv1 protocol that exists as a result of spoofing the FID header value
SMB packet of one transaction, value from another, and subsequent erroneous transaction lookup at runtime
SMB_COM_WRITE_ANDX commands. This allows the fields of the TRANSACTION structure to be overwritten with arbitrary data, which gives
the ability to execute code in kernel mode.

1.2 ETERNALBLUE
The exploit is based on a vulnerability in the SMBv2 protocol, which exists due to an incorrect entry in the size field.
SMB_FEA_LIST. A WORD-sized value is copied to ULONG without zeroing out the high-order (31-16) bits of this field. So
Thus, it becomes possible to set an oversized FEA buffer and overflow it, which leads to overwriting SRVNET_BUFFER_HDR
structures of the srvnet.sys driver. This makes it possible to control the contents of the MDL of this structure and further write the shellcode to
system memory and transfer control to it.

Although this vulnerability is present in systems starting with W8 and higher, exploitation on them is extremely difficult due to the fact that the
SMBv2 protocol policy that does not allow anonymous users to establish sessions. Those. to set up a session and
to execute an exploit, you need to have at least one shared folder and you also need to know the username / password of the user.

2. Description of the RCE of the ETERNALBLACK binding

As already mentioned, the bundle consists of 2 components: ETERNALROMANCE and ETERNALBLUE.
Both exploits are written from scratch and therefore are executed where FUZZBUNCH does not work for some reason.

The result of the exploit is the execution of the payload in the context of the target system process.
The payload must contain a reloc section and the entry point must match the DllMain function.

BOOL __stdcall DllMain(
HINSTANCE hinstDLL, // handle to DLL module
DWORD fdwReason, // reason for calling function
LPVOID lpvReserved // reserved
);

This procedure is called in the shellcode as follows:

if (EntryPoint != 0)
{
DLLMAIN dllmain = (DLLMAIN)(ImageBase + EntryPoint);

if (dllmain((HINSTANCE)ImageBase, DLL_PROCESS_ATTACH, pLdrData))
pvRet = ImageBase;
}

where ImageBase is the base of the mapped payload;
pLdrData - address of the shellcode service structure (passed

----------------------------------------
										ETERNALBLACK 1.1.2125

Что нового:

1) Сделана переделка и оптимизация кода движка (ядерного шелкода) и клиента

2) Изменен принцип загрузки пэйлоада. Теперь процесс разбит на две части:
	1 часть - TOUCH - проверка на уязвимость и начальная загрузка ядерного шелкода с бэкдором
	2 часть - UPLOAD&RUN  - загрузка собственно пэлоада и его запуск. Размер ПЛ ограничен 1Мб (на этом размере ПЛ и проводился прогон по всем осям)
  Соответственно возможных режима теперь 3:
   1 режим - только TOUCH
   2 режим - TOUCH + UPLOAD&RUN
   3 режим - UPLOAD&RUN (загрузка через ранее установленный бэкдор)
   Бэкдор держится до ребута. Бэкдор ядерный (от юзермодного агента отказался)
   Дозагружать можно многократно, пока не забъется память системного процесса куда инжектимся.
   Целевой процесс также можно менять.
   Данный алгоритм загрузчика резко повысит надежность загрузки пэйлоада и снизит вероятность сбоя.

3) Код доработан для работы в многопоточном режиме.

;------------------------------------------------------------------------------------------------------------------------------------------------------;

										ETERNALBLACK RCE. 
								Техническое описание и принцип работы.

1.Описание эксплуатируемых уязвимостей.

	ETERNALBLACK представляет собой связку из двух эксплоитов, которые используют почти те же принципы эксплуатации что и 
	эксплоиты из набора фрэймворка FUZZBUNCH от Shadow Brokers Group. Для удобства оба компонента ETERNALBLACK названы
	теми же именами, что и 2 компонента FUZZBUNCH.

	Это эксплоит ETERNALBLUE (охватывает 2008/W7/2008R2) и ETERNALROMANCE (XP/2003 x86/x64). Оба эксплоита были пропатчены MS
	14.03.2017 года в пакете обновлений безопасности MS17-010:

	Windows XP with Service Pack 2 x86/x64	KB4012598
	Windows XP with Service Pack 3 x86/x64	KB4012598
	Windows Server 2003 SP1/SP2 x86/x64		KB4012598
	Windows Vista with Service Pack 2 x86	KB4012598
	Windows Vista with Service Pack 2 x64	KB4012598
	Windows Server 2008 with Service Pack 2 x86	KB4012598
	Windows Server 2008 with Service Pack 2 x64	KB401259
	Windows 7 with Service Pack 1 x86	KB4012212 or KB4012215
	Windows 7 with Service Pack 1 x64	KB4012212 or KB4012215
	Windows Server 2008 R2 with Service Pack 1	KB4012212 or KB4012215
	Windows 8.1 x86	KB4012213 or KB4012216
	Windows 8.1 x64	KB4012213 or KB4012216
	Windows Server 2012	KB4012214 or KB4012217
	Windows Server 2012 R2	KB4012213 or KB4012216
	Windows 10 x86	KB4012606
	Windows 10 x64	KB4012606
	Windows 10 version 1511 x86	KB4013198
	Windows 10 version 1511 x64	KB4013198
	Windows 10 version 1607 x86	KB4013429
	Windows 10 version 1607 x64	KB4013429
	Windows Server 2016	KB4013429

1.1 ETERNALROMANCE
	Этот эксплоит основан на уязвимости в протоколе SMBv1, которая существует в результате подмены FID значения заголовка
	SMB пакета одной транзакции, значением от другой и последующим ошибочным поиском транзакции во время выполнения
	команды SMB_COM_WRITE_ANDX. Это позволяет перезаписывать поля структуры TRANSACTION произвольными данными, что дает
	возможность исполнения кода в режиме ядра.

1.2 ETERNALBLUE
	Эксплоит базируется на уязвимости в протоколе SMBv2, которая существует из-за неправильной записи в поле, определяющее размер
	SMB_FEA_LIST. Значение, размером в WORD, копируется в ULONG и при этом не обнуляя старшие (31-16) биты этого поля. Таким
	образом появляется возможность установки завышенного размера FEA буфера и его переполнения, что ведет к перезаписи SRVNET_BUFFER_HDR 
	структуры драйвера srvnet.sys. Это дает возможность контролировать содержимое MDL этой структуры и дальнейшей записи шеллкода в 
	системную память и передачи на него управления.

	Хотя данная уязвимость присутствует в системах начиная с W8 и выше, эксплуатация на них крайне затруднительна из-за того, что поменялась
	политика SMBv2 протокола, которая не позволяет устанавливать сессии анонимным пользователям. Т.е. чтобы установить сессию и
	выполнить эксплоит, нужно чтобы была хотя бы одна расшаренная папка и также нужно знать логин/пароль пользователя.

2. Описние RCE связки ETERNALBLACK

	Как уже сказано, связка состоит из 2ух составных частей: ETERNALROMANCE и ETERNALBLUE.
	Оба эксплоита написаны с нуля и поэтому исполняются там где FUZZBUNCH не работает по каким-то причинам.

	Резултатом работы эксплоита является выполнение полезной нагрузки в контексте целевого системного процесса.
	Полезная нагрузка должна содержать секцию релоков и точка входа должна соответствовать DllMain функции.

	BOOL __stdcall DllMain(
				HINSTANCE hinstDLL,	// handle to DLL module 
				DWORD fdwReason,	// reason for calling function
				LPVOID lpvReserved 	// reserved
				);

	Вызов это процедуры происходит в шеллкоде следующим образом:

	if (EntryPoint != 0)
	{
		DLLMAIN dllmain = (DLLMAIN)(ImageBase + EntryPoint);

		if (dllmain((HINSTANCE)ImageBase, DLL_PROCESS_ATTACH, pLdrData))
			pvRet = ImageBase;
	}
	
	где ImageBase это база отмапленной полезной нагрузки;
		pLdrData - адрес служебной структуры шеллкода (передается в отладочных целях, см. expdata_x86.h, expdata_x64.h );
			
2.1 Структура исходного кода 

	Проект организован (см. граф includes.xps) одновременно и как инструмент для загрузки своего кода на машину жертвы и как источник 
	исходного кода для других проектов.

	Стартовая функция находится в модуле main.cpp -> BOOL EternalBlack(PCHAR pcTargetHost, WORD wTargetSmbPort)
	Она возвращает TRUE в случае успешной реализации уязвимости, т.е. загрузки и запуска полезной нагрузки на сервер жертвы.
	Параметры говорят сами за себя. В адресе хоста допустим не только IP но и доменное имя.

	eb.cpp - 			 головной модуль связки где происходит инициализация SMB сессии, определение версии Windows хоста и выполнение в зависимости от версии базовых
						 функций ETERNALROMANCE (XP/2003) или ETERNALBLUE (2008/W7/2008R2).
			 
	romance_x86.cpp , 
	romance_x64.cpp - 	 модули с кодом эксплуатации ETERNALROMANCE
	blue.cpp -  	  	 модули с кодом эксплуатации ETERNALBLUE
	common.cpp, 
	common_network.cpp - общие функции проекта
	dbg.cpp - 			 модуль для отладочного вывода в консоль. Если из настроек препроцессора конфига RTM убрать DEBUG_OUTPUT_RTM, то dbg модуль и
						 все связанные с ним ресурсы не войдут в бинарник и сообщений в консоли не будет вообще.
	smb.cpp - 			 здесь расположен протокол SMB
	shells_x86.h , 
	shells_x64.h - 		 заголовки с ядерным шеллкодом
	expdata_x86.h,
	expdata_x64.h - 	 структуры данных для работы ядерного шеллкода

	ВНИМАНИЕ! shells_x86.h, shells_x64.h, expdata_x86.h, expdata_x64.h - данные в этих заголовках менять нельзя, они увязаны с офсетами внутри ядерного шеллкода !

	common_data.h - 	 здесь лежат настройки с именем целевого системного процесса и маской его командной строки запуска (для поиска нужного).
						 Если маска не используется, должно стоять значение NULL

	В папке common_inc расположены общие заголовочные файлы и дебаг модуль.

2.2 Алгоритм работы

	В начале производится инициализация сессии с сервером по пртоколу SMB, затем по отклику производится детект версии операционной системы и
	по возможности архитектуры. Детект архитектуры на этом этапе доступен только для XP/2003. Далее, в зависимости от версии происходит
	переход на EternalRomance_x[86/64] или EternalBlue. Количество попыток для EternalRomance - 1, для EternalBlue - 2. Это связано с
	особенностями спрэя ядерной памяти необходимыми данными для срабатывания уязвимостей. В случае с ETERNALBLUE несработка с первой
	попытки происходит в 5% случаях, для закрытия этих 5% используется 2 попытка. Для EternalRomance достаточно 1 попытки, если
	система уязвима, то эксплоит сработает. Не желательно запускать EternalRomance на уже "пробитую" машину без ребута, вероятен BSOD.

2.3. Сборка проекта
	Проект собран в VS2015 и имеет только одну стороннюю зависимость - DDK версии 7600.16385.1. В проекте указан путь C:\WinDDK\7600.16385.1
	Рабочих конфигураций две: Debug и RTM . Конфигурация Release резервная и не используется (не настроена).

3. Тестирвание
	Запускать так: eb.exe <target_address> <payload32.exe> [<payload64.exe>]
	Если не указан payload64.exe, то считается, что полезная нагрузка универсальна для обоих случаев x86/x64 и используется payload32.exe
	Если полезная нагрузка не указана совсем (только IP), это означает, что будет работа в режиме TOUCH.

	Во время выполнения произойдет коннект на 445 порт и тестирование на уязвимость MS17-010
	Для тестирования в папке test а также в папках с откомпилированным бинариником bin_rtm лежат тестовые ехе test_payload_x64.exe и
	test_payload_x86.exe. Они выполняют CreateProcessA(..,"cmd.exe",..)

	Перед выполнением необходимо проверить открыт ли фаерволом смб порт 445 или отключить фаервол.
	Если эксплуатация прошла удачно, произойдет выполнение шеллкода в контексте системного сервиса svchost.exe ( -netsvcs) 

	Ядерный шеллкод загружает полезную нагрузку соответствующей разрядности в память системного процесса (svchost), которая, в свою очередь,
	производит запуск cmd.exe.

	Исполнение контролируется визуально на системах 2003/XP и с помощью Process Explorer на 2008/W7 т.к. GUI cmd.exe, запущенного в
	контексте системного процесса не отображается на десктопе. т.е. нужно смотреть в процессах наличие cmd запущенного от свцхвоста. 
	Иногда (например в W7) GUI cmd.exe все же можно увидеть с помощью "Interactive Services Detection", который появляется на таскбаре.
  -------------------------------------------------------------------------------------------------
  
  
